# 쓰레드 thread

## 프로세스
- 실행 중인 프로그램
- 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 된다.
    ![img.png](images/program&process.png)
- 프로그램 수행 시 필요한 자원(데이터,메모리 등)과 쓰레드(최소 하나 이상)로 구성
    - 자원을 이용해서 작업 수행하는 것이 쓰레드!
    
    > ### 싱글쓰레드(single-threaded process) / 멀티쓰레드(multi-threaded process)
    > ![img.png](images/multi-threaded-process.png)
    > - 둘 이상의 쓰레드를 가진 프로세스를 '멀티쓰레드 프로세스' 라고 한다
    > > **❓ 프로세스가 가질 수 있는 쓰레드 개수는 제한이 있을까요?**</br></br>
        제한되어 있지 않습니다! 
        </br>다만, 쓰레드는 작업을 수행하는데 메모리 공간(호출스택)이 필요합니다.
        </br>따라서 프로세스의 메모리 한계에 따른 개수 제한이 있다고 볼 수 있습니다.
        </br></br>(실제로는 프로세스의 메모리 한계에 다를 정도로 많은 쓰레드를 생성하는 일은 없어 걱정하지 않아도 된다고 합니다:)

## 멀티프로세스(멀티태스킹,다중작업) vs 멀티쓰레드(멀티 쓰레딩)
- 멀티태스킹 : 동시에 여러 프로세스를 실행시키는 것
- 멀티쓰레딩 : 하나의 프로세스 내에 동시에 여러 쓰레드를 실행시키는 것
  > 멀티태스킹이 가능함으로써 프로그램을 다운받으면서 웹서핑을 동시에 할 수 있게 된다.

  > **멀티쓰레딩의 장점**
  > - CPU의 사용률을 향상시킨다．
  > - 자원을 보다 효율적으로 사용할 수 있다．
  > - 사용자에 대한 응답성이 향상된다．
  > - 작업이 분리되어 코드가 간결해진다． 
  > 
  > 멀티쓰레딩이 가능함으로써 메신저로 파일을 다운로드하면서 채팅을 할 수 있게 된다.
  > 
  > **멀티쓰레딩의 단점**
  > 
  > - 동기화(synchronization)
  > - 교착상태(deadlock) : 두 쓰레드가 자원을 점유한 상태에서 서로 상대펀이 점유한 자원을 사용하려고 기다리느라 진행이 멈춰있는 상태
  > 
  > 아래에서 싱글쓰레드와 멀티쓰레드의 차이점을 좀 더 자세히 보겠습니다.   
  

## 쓰레드의 구현과 실행
1. Thread클래스를 상속받는 방법
   -  다른 클래스를 상속받을 수 없다.
        ```java
        class MyThread extends Thread {
            public void run() { /* 작업내용 */ } // Thread클래스의 run(）을오버라이딩
        }
        ```
2. Runnable인터페이스를 구현하는 방법 
    - 재사용성(reusability)이 높고 코드의 일관성(consistency)을 유지할 수 있기 때문에 보다 객쳬지향적인 방법
        ```java
        class MyThread implements Runnable {
            public void run() { /* 작업내용 */ } // Runnable인터페이스의 run(）을구현
        } 
        
        ```
        > **Runnable인터페이스** : 오로지 run(）만 정의되어 있는 간단한 인터페이스
        > ```java
        > public interface Runnable {
        >     public abstract void runO;
        > }
        > ```
 
> ### Thread 클래스 상속 vs Runnable 인터페이스 구현
> ```java
> class ThreadExl {
>  public static void main(String args[]) {
>    //인스턴스 생성 방법이 다르다.
>    ThreadEx1_1 t1 = new ThreadEx1_1();
> 
>    Runnable r = new ThreadEx1_2();
>    Thread t2 = new Thread(r); // 생성자 Thread(Runnable target)
>    t1.start(); //start()를 하면 실행대기 상태로 있다가 자신의 차례가 오면 실행 
>    t2.start(); //-> 내부적으로 run() 수행
>    //한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다 
>    // = 하나의 쓰레드에 대해 start(）가 한 번만 호출될 수 있다
>    // 한 번 더 실행하려면 새로 생성해줘야함
>  }
> }
> class ThreadEx1_1 extends Thread {
>   public void run() {
>     for(int i=0; i < 5; i++) {
>       System.out.println (getName()); // 조상인 Thread의 getName()을 직접호출
>     }
>   }
> }
> class ThreadEx1_2 implements Runnable {
>   public void run() {
>     for(int i=0; i < 5; i++) {
>     // Thread. currentThread() - 현재실행중인 Thread를반환한다．
>     System.out.println(Thread.currentThread().getName()); 
>                             //쓰레드에 대한 참조를 얻어 와야 호출가능
>   }
>   }
> }
>```
> 
>- 결과<br>
>  ![img.png](images/result3.png) ![img_1.png](images/result2.png) ![img_2.png](images/result.png)
> 
> 
> - 참고) ![img.png](images/java_lang_Thread.png) 에 있는 소스코드
>    ![img_3.png](images/currentThread.png)<br>
>    ![img_2.png](images/thread_getName.png)<br>
>   ![img_3.png](images/Thread.png)<br>
>   ![img_4.png](images/Thread2.png)<br>
>   ![img.png](images/run.png) target : private Runnable target;<br>
>   ![img.png](images/start.png)



## run() vs start()
- run() : 단순 클래스의 선언된 메서드를 호출(생성된 쓰레드를 실행시키는 것이 아님)
- start() : 쓰레드 실행
    - 새로운 쓰레드가 작업을 실행하는데 필요한 **호출스택（call stack）을 생성**한 다음 
      run(）을 호출해서, 생성된 호출스택에 run(）이 첫 번째로 올라가게 한다.
      (쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요)
      ![img.png](images/call_stack.png)
    - 새로운 쓰레드를 생성하고 실행시킬 때마다 <br>새로운 호출스택이 생성되고 <br>쓰레드가 종료되면 작업에 사용된 호출스택은 소멸
    ![호출스택 변화](images/호출스택변화.png)
      > main메서드의 작업을 수행하는 것도 쓰레드
    
> 실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다．  

## 싱글쓰레드 vs 멀티쓰레드
![img.png](images/singleTh-multiTh.png)</br>
1. 한 작업 마친 후 다른 작업 
2. 짧은 시간동안 두 개의 쓰레드가 번갈아 가면서 작업
> 두 경우 최종 수행 시간은 거의 같지만 쓰레드간의 작업 전환(context switching)에 시간이 걸려 두 개의 쓰레드로 작업한 시간이 더 오래 걸린다고한다.
> 
> > 작업을 전환할 때는 작업의 상태(다음에 실행할 위치 등)정보를 저장하고 읽는 시간이 소요된다고 합니다.

![img.png](images/th_concurrent_parallel.png)</br>
- 싱글 코어 일 경우, 두 작업이 겹치지 않음
- 멀티 코어 일 경우, 동시에 두 쓰레드가 수행될 수 있으므로 작업이 겹칠 수 있음
> 병행（concurrent) : 여러 쓰레드가 여러 작업을 동시에 진행</br>
> 병렬（parallel） : 하나의 작업을 여러 쓰레드가 나눠 처리

## 쓰레드의 우선순위
![img.png](images/priority.png)
![img.png](img.png)
- 작업의 중요도에 따라 쓰레드의 우선순위 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.
- 가질 수 있는 우선순위의 범위는 1-10
-  숫자가 높을수록 우선순위가 높음
- 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다.
    </br>(main메서드를 수행하는 쓰레드는 우선순위가 5이므로 main메서드 내에서 생성하는 쓰레드의 우선순위는 자동적으로 5)
  