# JVM

---

## What is JVM?
- JVM이란 Java Virtual Machine 의 줄임말로, Java Byte Code 를 운영체제에 맞게 해석해주는 역할을 합니다. 즉, 작성한 자바 프로그램의 실행 환경을 제공하는 자바 프로그램의 구동 엔진입니다.
- Java compiler 는 .java 파일을 .class 라는 자바 바이트코드로 변환시켜주는데 Byte Code 는 기계어(Native Code)가 아니므로 OS 에서 바로 실행이 되지 않습니다. 이때 JVM은 OS가 Byte Code 를 이해할 수 있도록 해석해주는 역할을 담당합니다.
- JVM은 메모리 관리도 담당합니다. 이를 '가비지 컬렉터'라고 하는데, 가비지 컬렉터는 Java7부터 힙 영역의 객체들을 관리하는 역할을 담당합니다.

## JVM은 힙을 세 개의 영역으로 나누어 관리한다
### Java의 GC, 가비지 컬렉터
- 어떠한 객체를 생성하였을 때, 이 객체를 사용하기 위해 메모리에 적재가 됩니다. 사용이 완료된 후 할당받은 메모리 공간을 비워주지 않으면 불필요한 메모리 공간이 누적이 되어 자바 프로그램이 많은 메모리 사용률을 보이게 되면서 서버에서 실행중인 프로그램이 정상 동작하지 않거나, 중단이 되는 현상이 발생할 수도 있는데, 자바에서는 가비지 컬렉터라는 것이 동적으로 공간을 정리해줍니다.
- 일부 관리되지 않는 외부 리소스(unmanaged resource)는 수동으로 메모리 해제를 하여야 합니다.
- C언어 같은 경우에는 동적 메모리 할당을 통해 힙 영역의 데이터를 읽고 쓰는데, 사용자가 직접 동적 메모리 할당을 해제하여야 하는 어려움이 있다고 합니다. (malloc)
- JAVA는 힙 영역의 메모리 관리를 사용자가 하지 않고 GC가 처리합니다.
![JVM](https://velog.velcdn.com/images%2Fpearl0725%2Fpost%2F13875c20-35c9-4001-9660-6698eabf99a8%2Fimage.png)
#### New/Young Generation  
> 새로 생성된 객체를 저장합니다. → 객체가 힙에 최초로 할당이 되는 장소라는 의미입니다.
- Oracle JVM 에서는 새로 생성되었거나, 생성된 지 얼마 되지 않은 객체는 Eden 영역에 저장이 됩니다. Eden 영역에 일정 수준 이상으로 사용률을 보이면 가비지 컬렉션이 발생하여 객체의 참조 여부를 따져 참조가 되어 있는 사용중인 객체라면 Survivor 영역으로 이동하고, 참조가 끊어진 Garbage 객체라면 남겨놓은 후, 사용중인 객체들이 모두 Surivor 영역으로 넘어가면 Eden 영역을 모두 청소합니다.
- Young Generation 의 Survivor 영역은 Eden 영역에서 청소되지 않은 객체들이 할당받은 공간인데, 이 Survivor 영역은 두 개로 구성이 됩니다. 이것을 Minor GC 라고 칭한다고 합니다.
- 왜 Survivor 영역은 두 개로 구성이 될까요? 하나의 Survivor 영역이 차게 되면, 다른 영역으로 복사가 됩니다. 이때 Eden 영역에 있던 살아남은 객체들은 다른 Survivor 객체로 넘어갑니다. → 즉, 둘 중 하나는 반드시 비어 있어야만 합니다.

#### Old Generation  
> 만들어진지 오래된 객체를 저장합니다. → Survivor 영역에서 살아있는 객체로 오래 남아 있던 객체는 Old Generation 으로 이동하게 됩니다. *특정 회수 이상 참조가 되어 기준 Age를 초과한 객체를 의미합니다.
- 어떻게 설정을 하였느냐에 따라 다르지만, 오래 생성되어 있어야 하는 객체는 가비지 컬렉션을 거치면서 Old 영역으로 이동을 하게 됩니다.
- 즉, 비교적 오랫동안 참조가 되어 이용되고 있고 앞으로도 지속적으로 사용할 확률이 높은 객체들을 저장하는 영역입니다.
- Old Generation의 메모리도 충분하지 않으면, 해당 영역에도 GC가 발생하는데 이를 Full GC(Major GC)라고 합니다.

#### Permanent Generation  
> JVM 클래스와 메서드 객체를 저장합니다.
- JDK8 부터는 해당 Heap 영역이 제거가 되었다고 합니다. 이 친구는 JVM에 의해 크기가 강제되던 영역이었는데, 대신에 Metaspace 영역이 추가가 되었고 해당 영역은 OS가 자동으로 크기를 조절합니다. → OS 레벨에서 관리되는 영역, Metaspace가 Native 메모리를 이용함으로써 개발자는 영역 확보의 상한을 크게 의식할 필요가 없어지게 되었다고 합니다. (기존에는 힙 영역 외에 Perm 영역을 별도로 튜닝을 하였다고 합니다.) Java8 부터는 튜닝 옵션을 주어 성능 튜닝을 한다고 하는데, 추후에 싱글 쓰레드와 멀티 쓰레드를 공부하게 되면 해당 부분은 꼭 공부해보고 싶다는 생각이 되네요!

---
[출처] :
https://velog.io/@pearl0725/JVM%EC%9D%80-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%A0%EA%B9%8C
