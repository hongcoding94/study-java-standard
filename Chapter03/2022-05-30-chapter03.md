# Chapter 3 연산자
## 3-1. 연산자와 피연산자
> **연산자**
> - '연산을 수행하는 기호'
- 자바에서는 사칙연산을 비롯하여 다양한 연산자를 제공한다.
- 연산자가 연산을 수행하려면 반드시 하나 이상의 연산의 대상이 있어야 하는데, 이것을 **피연산자(operand)** 라고 표현한다.
- 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것을 **식(expression)** 이라고 표현한다.
- 이러한 식을 계산하여 결과를 얻는 것을 **식을 평가(evaluation)한다** 라고 표현한다.
- 하나의 식을 평가(계산)하면 단 하나의 결과를 얻는다.

## 3-2. 연산자의 종류
- 연산자의 종류는 다음과 같다.

|종류|          연산자           |설명|
|:---:|:----------------------:|:---|
|산술 연산자|   +, -, *, %, <<, >>   |사칙 연산과 나머지 연산(%)|
|비교 연산자	| \>, <, >=, <=, ==, !=	 |두 피연산자를 비교|
|논리 연산자	|          &&,           ||, !, &, |, ^, ~	|'그리고(AND)'와 '또는(OR)'으로 조건을 연결|
|대입 연산자	|           =	           |우변의 값을 좌변에 저장|
|부호 연산자	|         -, +	          |해당 값의 부호를 명시|
|기타	| (type) ?: instanceof	  |형변환 연산자, 삼항 연산자, instanceof 연산자|
- 연산자는 피연산자의 개수로 연산자를 분류하기도 하며, 피연산자의 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자라고 표현한다. 
- 대부분의 연산자는 **이항 연산자**이다.
```java
-3 - 5
```
- 위의 예시를 보면, 이항 연산자이자 산술 연산자인 - 연산자의 피연산자는 -3과 5이므로 -3과 5의 사칙연산을 요구하는 연산자이고, 단항 연산자이자 부호 연산자인 - 연산자의 피연산자는 3으로 3이라는 숫자의 부호를 - 연산자를 통해 음수임을 표시한 것이다.

## 3-3. 연산자의 우선순위
## 3-4. 연산자의 결합규칙
- 식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.
- 연산자 우선순위가 같다면, 연산 방향에 따라 달라지며 이를 결합규칙이라고 표현한다.

- 연산자의 우선순위와 결합규칙(연산 방향)은 다음과 같다.

|   우선순위    |                        연산자                         |        피연산자         | 연산 방향 |
|:---------:|:--------------------------------------------------:|:-------------------:|:----:|
|     0     |                    () 괄호 속 연산자	                    |         다양	         |   -  |        
|     1     | 증감 (++, --), 부호 (+, -), 비트 (~), 논리 (!), 캐스팅 (())	  |         단항          |  	<- |
|     2     |                   산술 (*, /, %)	                    |         이항          |  	-> |
|     3     |                     산술 (+, -)	                     |         이항          |  	-> |
|     4     |                 쉬프트 (>>, <<, >>>)	                 |         이항          |  	-> |
|     5     |           비교 (<, >,<=, >=, instanceof)	            |         이항          |  	-> |
|     6     |                    비교 (==, !=)	                    |         이항          |  	-> |
|     7     |                      비트 (&)	                       |         단항          |  	-> |
|     8     |                      비트 (^)	                       |         단항          |  	-> |
|     9     |                      비트 (｜)	                       |  단항  |	->|
|    10     |                      논리 (&&)	                      |         이항          |  	-> |
|    11     |                   논리 ( ｜｜     )	                   |이항|	->|
|    12     |                     조건 (? :)	                      |         삼항          |  	-> |
|    13     | 대입 (=, +=, -=, /=, %=, &=, ^=,｜=, <<=, >>=, >>>=)	 |  이항  |	<-|
- 산술 연산식에서는 사칙연산에 따라 연산자의 우선순위가 정해지며, 증감 연산자와 대입 연산자를 제외한 나머지 연산자는 연산 방향이 우측이다.
```java
x > 0 && y < 0
```
- 비교 연산자는 우선순위가 5이고, 논리 연산자는 우선순위가 10이기 때문에 x > 0과 y < 0에 대한 연산이 먼저 이루어진 다음 마지막으로 && 연산자에 의해 연산이 마무리된다.
```java
100 * 2 / 3 % 5
```
- 모든 연산자들의 우선순위가 2이기 때문에 연산 방향인 우측에 따라서 연산이 진행된다.
```java
a = b = c = 5
```
- 모두 대입 연산자이므로 연산 방향이 오른쪽에서 왼쪽으로 진행된다.
- 즉 c = 5 -> b = c -> a = b 순으로 진행된다.
```java
-x + 3
```
- 부호 연산자의 우선순위는 1, 산술 연산자의 우선 순위는 3이므로 먼저 x의 값에 부호 연산자 -로 인해 부호가 변환된 다음, 산술 연산자 +가 실행된다.
```java
x + 3 * y
```
- \* 연산자는 우선순위가 2이고 + 연산자는 우선순위가 3이므로 3 * y 식이 먼저 실행된 이후 x + (3 * y)에서의 + 연산이 실행된다.
```java
x + 3 > y - 2
```
- 연산자는 우선순위가 5이고 +, - 연산자는 우선순위가 3이므로 먼저 x + 3, y - 2 식이 실행된 이후 (x + 3) > (y - 2)에서의 > 연산이 실행된다.
```java
result = x + y * 3
```
- = 연산자의 우선순위는 13, + 연산자의 우선순위는 3, * 연산자의 우선순위는 2이므로 우선 y * 3 식이 연산된 이후 x + (y * 3)에서의 + 연산이 실행되고, 사칙연산이 끝난 뒤 그 결과값이 = 연산자로 인해 result 변수에 저장된다.

## 3-5. 증감 연산자 ++과 --
- 증감 연산자는 피연산자에 저장된 값을 1 증가 또는 감소시킨다.
- 상수의 경우 한 번 저장한 값을 변경할 수 없기 때문에 사용할 수 없다.

0 증감 연산자는 일반 산술 변환에 의한 자동 형변환이 발생하지 않으며, 그러므로 연산결과의 타입은 피연산자의 타입과 같다.

> - 증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
> - 감소 연산자(--) : 피연산자의 값을 1 감소시킨다.
- 이러한 증감 연산자는 좌측에 존재하는 전위형(prefix)과 우측에 존재하는 후위형(postfix)으로 구분할 수 있으며, 그에 대한 정보는 다음과 같다.

|타입|           설명            |사용 예시|
|:-----:|:-----------------------:|:-----:|
|전위형|값이 참조되기 전에 증가시킨다.|j = ++i;|
|후위형|    값이 참조된 이후에 증가시킨다.    |j = i++; |
- 그러나 증감 연산자를 실행하는 구간에서 증감 연산자 외의 동작이 없을 경우에는 전위형과 후위형 모두 동작 결과는 동일하다.

#### 다음 3-3 예제를 보고 해당 내용을 확인해보자.
```java
class Ex3_3 {
    public static void main(String args[]) {
        int i=5, j=5;
        System.out.println(i++);
        System.out.println(++j);
        System.out.println("i = " + i + ", j = " +j);
    }
}
```
- int i=5, j=5 로 인해 i와 j의 값은 모두 5로 초기화된 상태이다.
- System.out.println(i++) : 값이 참조된 이후에 증가시키기 때문에, System.out.println() 메소드의 인자로는 i의 초기값 5가 들어간다. 그 이후, System.out.println() 메소드가 i의 값 5를 출력한 이후 후위형 증감 연산자로 인해 1 증가시킨다.
- System.out.prinln(++j) : 값이 참조되기 이전에 증가시키기 때문에, System.out.println() 메소드의 인자로는 j의 값에 증가 연산자가 적용된 6이 들어간다. 그러므로 해당 구간에서는 6이 출력된다.
- System.out.println("i = " + i + ", j = " +j) : i의 값은 i++로 인해 6인 상태이고, j의 값은 ++j로 인해 6인 상태이므로 모두 6이 출력된다.

#### 그러므로 해당 예제의 실행 결과는 다음과 같다.
```java
5
6
i = 6, j = 6
```

## 3-6. 부호 연산자
- 부호 연산자는 +, -가 있으며 실질적으로 데이터에 영향을 끼치는 연산자는 - 하나이다.
- 연산자는 해당 연산자의 값에 -1를 곱한다.
- 즉 피연산자가 음수면 양수, 양수면 음수가 연산의 결과가 된다.
- 부호 연산자는 boolean과 char를 제외한 나머지 기본형에서 사용할 수 있다.

## 3-7. 형변환 연산자
- 서로 다른 타입 간의 연산을 수행해야 할 경우, 각 피연산자의 타입을 일치시켜야 한다.
- 이와 같이 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 형변환(casting)이라고 한다.
#### 즉 형변환은 다음과 같이 설명할 수 있다.
- 형변환이란 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- 형변환 방법은 (타입)피연산자와 같이 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 명시한다.
- 여기서 사용하는 괄호()는 캐스트 연산자 또는 형변환 연산자라고 하며, 이렇게 형변환을 할 타입을 형변환 연산자로 명시하는 방식을 명시적 형변환이라고 표현한다.
```java
double d = 85.4;
int score = (int)d;
```
#### 위와 같은 예시는 다음과 같은 단계를 거친다.
```java
int score = (int)d; -> int score = (int)85.4; -> int score = 85;
```
- 이 과정에서 알 수 있듯이, 형변환 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환한다.
- 즉 피연산자인 변수 d의 값은 형변환 이후에도 아무런 변화가 없다.
- 또한 이와 같이 명시적 형변환을 통해 double을 int로 강제로 형변환을 진행하다 보니, double 보다 표현 범위가 작은 int형으로 변환하면서 데이터가 손실되는 것을 확인할 수 있다.

- 이처럼 double이나 float같은 실수형 데이터 타입을 int와 같은 정수형 데이터 타입으로 변환할 때에는 항상 실수형 데이터 타입이 표현 범위가 정수형보다 크기 때문에 소수점이 삭제된 것이다.
- 이는 byte와는 상관 없는 동작이며, long 타입은 8 byte이고 float 타입은 4 byte이지만 표현 범위는 long 타입보다 float 타입이 더 크기 때문에 float에서 long 타입으로 변환 시 값의 손실이 발생한다.

## 3-8. 자동 형변환
- 서로 다른 타입 간의 대입이나 연산을 할 때, 먼저 형변환으로 타입을 일치시키는 것이 원칙이지만 편의상의 이유로 형변환을 생략할 수 있다.
- 이렇게 생략한 경우는 형변환이 이루어지지 않는 것은 아니며, 컴파일러가 생략된 형변환을 자동으로 추가해준다.
```java
float f = 1234;
```
- 위 예시의 경우 좌항의 데이터 타입(float)와 우항의 데이터 타입(int)가 달라 형변환이 필요하지만, float 타입의 변수는 1234라는 값을 저장하는데 아무런 문제가 없으므로 생략이 가능하다.
- 그러나 이전 예시와 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에는 형변환을 생략하면 에러가 발생한다.
```java
byte b = 1000;
```
- 이 경우 byte 타입이 저장할 수 있는 값의 범위는 -128 ~ 127이기 때문에 1000을 저장할 수 없기 때문에에러가 발생한다.
- 이러한 경우를 해결하기 위해 명시적으로 형변환을 해준다면, 해당 형변환은 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.
```java
byte b = (byte)1000;
```
- 다만 값 손실이 발생하기 때문에 변수 b에는 -24가 저장된다.
- 형변환은 하는 이유는 주로 서로 다른 두 타입을 일치시키기 위해서인데, 형변환을 생략하면 가능한 경우에 한해서 컴파일러가 자동으로 형변환을 진행한다.
- #### 즉 아래와 같이 표현할 수 있다.
- > 기존의 값을 보존할 수 있는 타입으로 자동 형변환된다.
- 그러므로 표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.

![타입](https://velog.velcdn.com/images%2Fappti%2Fpost%2Fee1de46e-c496-42f6-8aed-b044343bdb18%2Fa.jpg)
- 위 그림은 형변환이 가능한 7개의 기본형을 왼쪽부터 오른쪽으로 표현할 수 있는 값의 범위가 작은 것부터 큰 것의 순서로 나열한 것이다.
- 화살표 방향으로의 변환, 즉 왼쪽에서 오른쪽으로의 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 되며, 그 반대 방향으로의 변환은 형변환 연산자를 써야한다.
- 형변환 연산자를 사용하는 경우 이를 **명시적 형변환** 이라고 표현하며, 자동 형변환의 경우 **묵시적 형변환** 이라고 표현한다.

## 3-9. 사칙 연산자
- 사칙 연산자의 경우 주의할 점이 두 가지 존재한다.

1. 피연산자가 정수형일 경우, 0으로 나눌 수 없다.
2. **/** 연산자는 데이터 타입에 따라 결과값이 변경된다.
```java
10 / 4 => 2
```
- 위의 예시와 같이 int형을 int형으로 나눴을 경우, 해당 식의 결과 또한 피연산자의 타입과 동일한 int형이기 때문에 실제 연산결과는 2.5이지만 int이 저장할 수 있는 범위 2만이 반환되는 것이다. 이 경우 저장할 수 없는 범위인 소수점은 모두 버려지므로, 반올림이 발생하지 않는다.

#### 그러므로 해당 예시에서 정확한 결과값을 얻고 싶다면
```java
10 / 4.0f => 10.0f / 4.0f => 2.5f
```
- 와 같이 하나의 피연산자를 int 형보다 범위가 넓은 float 형으로 지정한다면 묵시적 형변환에 의해 int형이 float형으로 형변환되고, float 형으로 반환되어 원하는 결과값을 반환받을 수 있다.

## 3-10. 산술 변환
- 이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.
- 이처럼 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 산술 변환 또는 일반 산술 변환이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다.
#### 다음은 산술 변환의 규칙이다.

1. 두 피연산자의 타입을 비교하여 보다 큰 타입으로 일치시킨다.
```java
long + int => long + long => long
float + int => float + float => float
double + float => double + double => double
```
2. 피연산자의 타입이 정수이고 int보다 작은 값이면 int로 변환된다.
```java
byte + short => int + int => int
char + short => int + int => int
```
3. 피연산자의 타입이 실수이고 double보다 작은 값이면 double로 변환된다.
```java
float + float => double + double => float
```
- 첫 번째 규칙은 피연산자의 값 손실을 최소화하기 위함이고, 두 번째, 세 번째 규칙은 int형보다 작은 타입의 경우 표현범위가 좁아서 연산 중에 오버플로우가 발생할 가능성이 높기 때문이다.
- 그렇기 때문에 정수형의 기본 타입을 int, 실수형의 기본 타입을 double이라고 표현한다.
- 그리고 또 하나 주의할 점은 연산결과의 타입인데, 연산결과의 타입은 피연산자의 타입과 일치한다는 점이다.
```java
byte a = 10;
byte b = 20;
byte c = a + b;
```
#### 위 예시는 컴파일 에러가 발생한다.
- 그 이유는 int보다 작은 데이터 타입을 연산할 때에는 int로 묵시적 형변환이 이루어지기 때문에, byte c = a + b => byte c = (int)a + (int)b와 같은 동작이 되기 때문에 반환값도 int이지만 int보다 표현 범위가 작은 byte 타입의 변수 c로 반환값을 받으려고 했기 때문이다.
#### 이러한 에러를 없애기 위해서는
```java
byte a = 10;
byte b = 20;
byte c = (byte)(a + b);
```
#### 혹은
```java
byte a = 10;
byte b = 20;
int c = a + b;
```
#### 위와 같은 변경이 필요하다.

```java
class Ex3_9 {
    public static void main(String args[]) {
    int a = 1_000_000; // 1,000,000 1백만
    int b = 2_000_000; // 2,000,000 2백만
    long c = a * b; // a * b = 2,000,000,000,000 ?
    System.out.println(c);
    }
}
```
#### 다음 예시에서도 문제가 발생한다.
- long 타입은 2,000,000,000,000을 담을 수 있기 때문에 문제가 없어 보이지만, 앞서 학습한 내용처럼 식의 반환값은 피연산자의 타입과 일치한다는 점으로 인해 문제가 발생한다.
- a * b의 타입은 모두 int * int이기 때문에, 반환값 또한 int가 되며 int의 표현 범위는 -214748648 ~ 2147483647로 2,000,000,000,000을 담을 수 없기 때문에 오버플로우가 발생하며, 오버플로우가 발생한 값이 long 타입 변수에 저장되기 때문이다.
```java
long c = a * b;
=> long c = 1000000 * 2000000;
=> long c = -1454759936;

1000000 * 1000000 => -727379968
```
- 그렇기 때문에 올바른 결과를 얻으려면 a 또는 b의 타입을 long으로 바꿔 묵시적 형변환을 통해 오버플로우를 방지해야 한다.
```java
long c = (long)a * b;
=> long c = (long)1000000 * 2000000;
=> long c = 1000000L * 2000000;
=> long c = 1000000L * 2000000L;
=>  long c = 2000000000000L;

1000000 * 1000000L => 1000000L * 1000000L => 1000000000000L
```

## 3-11. Math.round()로 반올림하기
- Math.round() 메소드를 통해 반올림이 가능하다.
- 해당 메소드는 소수점 첫 번째 자리에서 반올림한 결과를 정수로 반환한다.
- 그러므로 소수점 첫 번째 자리가 아닌 다른 자리에서 반올림을 하려면 10^n을 곱하고 다시 곱한 값으로 나누어야 한다.
```java
class Ex3_11 {
    public static void main(String args[]) {
    double pi = 3.141592;
    double shortPi = Math.round(pi * 1000) / 1000.0;
    System.out.println(shortPi);
    }
}
```
#### 이 예제의 동작 과정은 다음과 같다.
```text
Math.round(pi * 1000) / 1000.0
=> Math.round(3.141592 * 1000) / 1000.0
=> Math.round(3141.592) / 1000.0
=> 3142 / 1000.0
=> 3.142
```
#### 여기서 3142 / 1000.0 가 아닌 3142 / 1000 을 수행하면 두 피연산자 모두 int형이므로 3이 반환되기 때문에 원하는 결과값을 얻을 수 없다.

## 3-12. 나머지 연산자
- 나머지 연산자는 해당 식의 피연산자들을 나눈 뒤 그 나머지를 반환한다.
- 나눗셈과 동일하게 0을 나눌 수 없고, 정수만을 허용한다.
- 주로 홀/짝 검사나 배수 검사에 사용된다.

- 나머지 연산의 특징으로는 나누는 수로 음수도 올 수 있다는 점이다.
- 그러나 부호는 무시되기 때문에, 결과는 음수의 절대값으로 나눈 나머지와 결과가 같다.
```java
System.out.println(10 % 8);
System.out.println(10 % -8);
```
#### 두 코드 모두 2를 출력한다.

## 3-13. 비교 연산자
- 비교 연산자는 두 피연산자를 비교하는 데 사용되며, 주로 조건문과 반복문의 조건식으로 사용된다.
- 반환 타입은 **boolean** 으로, **true** 와 **false** 이다.
- 비교 연산자 또한 이항 연산자이므로 피연산자의 타입이 서로 다를 경우 자료형의 범위가 큰 쪽으로 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다는 점에서 주의가 필요하다.

### 대소비교 연산자 <, > <=, >=
- 두 피연산자의 값의 크기를 비교하는 연산자이다.
- 기본형 중에서는 boolean을 제외한 나머지 자료형에 사용할 수 있으며, 참조형에서는 사용할 수 없다.

|        비교연산자         |        연산결과        |
|:--------------------:|:------------------:|
|          >           |   좌변 값이 크면 true    |
|          <           |   좌변 값이 작으면 true   |
|          >=          | 좌변 값이 크거나 같으면 true |
| <=| 좌변 값이 작거나 같으면 true |

### 등가비교 연산자 == !=
- 두 피연산자의 값이 같은지를 비교한다.
- 모든 자료형(기본형, 참조형)에서 사용할 수 있다.
- 다만 동작 방식은 다른데, 기본형의 경우 값의 일치여부를 비교하며 참조형의 경우 객체의 주소값을 비교하여 두 개의 참조 변수가 서로 같은 객체를 가리키고 있는지를 비교한다.
- 그리고 기본형과 참조형을 비교할 수는 없다.

|        비교연산자         |        연산결과        |
|:--------------------:|:------------------:|
|==|	두 값이 같으면 true|
|!=|	두 값이 다르면 true|

## 3-14. 문자열의 비교
- 위에서 살펴본 등가비교 연산자의 경우 참조형은 객체의 주소값을 비교하여 두 개의 참조 변수가 서로 같은 객체를 가리키고 있는지를 비교한다고 학습했다.
- **String** 또한 참조형이기 때문에 객체의 주소값을 비교하게 되는데, 문자열의 경우 주로 내용을 비교하기 때문에 등가비교 연산자를 사용하기에는 적합하지 않다.
```java
String s1 = "aaa"; // String s1 = new String("aaa");
String s2 = "aaa"; // String s2 = new String("aaa");

System.out.prinln(s1 == s2) / / 무조건 false 출력
```
- s1과 s2는 값이 "aaa"로 같지만, 가리키고 있는 객체는 서로 다르기 때문에 무조건 false가 출력된다.
- 그렇기 때문에 문자열을 비교할 때에는 객체의 주소값을 비교하는 것이 아닌 객체에 담긴 값을 비교해야 하며, 이러한 역할을 수행하는 메소드는 String 클래스에 포함되어 있는 equals() 메소드이다.
```java
String s1 = "aaa"; // String s1 = new String("aaa");
String s2 = "aaa"; // String s2 = new String("aaa");

System.out.prinln(s1.equals(s2)) // true

String s3 = "aaa"; // String s3 = new String("aaa");
String s4 = "aAa"; // String s4 = new String("aAa");

System.out.println(s3.equals(s4)) // false
System.out.println(s3.equalsIgnoreCase(s4)) // true
```
- 여기서 문자열의 값을 비교할 때 대소문자를 무시하고 비교하고 싶다면 equalsIgnoreCase() 메소드를 사용하면 된다.

## 3-15. 논리 연산자 &&, ||, !
- 논리 연산자는 둘 이상의 조건을 '그리고(AND)' 나 '또는(OR)'로 연결하여 하나의 식으로 표현할 수 있게 해 준다.

> || (OR 결합) : 피연산자중 어느 한 쪽이 true면 true가 반환된다.
> 
> && (AND 결합) : 피연산자 양쪽 모두 true여야 true가 반환된다.
> 
#### 이를 표로 표현하면 다음과 같다.

|  x  |  y  | x ｜｜ y |  x && y |
|:---:|:---:|:----:|:-----:|
|   T |T|  T|T  |
|   T |F   |T  |F |
|  F|T   |T  |F |
|F|F|F|F|


## 3-16. 논리 부정 연산자
- 해당 연산자는 피연산자가 true이면 false를, false이면 true를 얻는다.
- 즉 true와 false의 반대를 반환한다.

#### 이를 표로 표현하면 다음과 같다.

|x|y|
|:----:|:-----:|
|T|F|
|F|T|
- 논리 부정 연산자를 잘 사용하면 조금 더 이해하기 쉬운 코딩이 가능하다.
```java
ch < 'a' || ch > 'z'
!('a' <= ch && ch <= 'z')
```
- 위 예시의 두 코드 모두 동일한 결과값을 반환하겠지만, '영어 소문자가 아닌 경우'라는 조건을 표현하고자 한 경우에는 두 번째 코드가 조금 더 이해하기 쉬울 것이다.

## 3-17. 조건 연산자
- 조건 연산자는 조건식, 식1, 식2의 세 가지 피연산자를 필요로 하는 삼항 연산자이다.
- 그리고 삼항 연산자에는 조건 연산자 단 하나만이 존재한다.
> 조건식 ? 식1 : 식2
- 조건 연산자는 첫 번째 피연산자인 조건식의 평가결과에 따라 다른 결과를 반환한다.
- 조건식이 true일 경우에는 식1을 반환하며, false일 경우에는 식2를 반환한다.
- 조건식의 경우 가독성을 위해 괄호()로 감싸는 경우가 많지만, ㅣㄹ수는 아니다.

- 조건 연산자는 if문으로 변경이 가능하다.
- 조건 연산자를 사용한 경우에는 코드의 수는 줄어들겠지만 이해하기가 조금 어려워지며, if문을 사용한 경우에는 코드의 수가 증가하지만 이해하기는 쉬워진다.

- 또한 조건 연산자도 식1과 식2의 데이터 타입이 다른 경우 산술 변환이 발생한다.

## 3-18. 대입 연산자
- 대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다.
- 대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 실행된다.

- x = 3과 같이 우측에는 변수 뿐만 아니라 식이나 상수 등이 모두 가능하지만, 좌측에서는 반드시 변수처럼 값을 변경할 수 있는 것이야 한다.
- 그러므로 리터럴이나 상수같이 값을 저장할 수 없는 것들이 좌측에 올 수 없다.

## 3-19. 복합 대입 연산자
- 대입 연산자는 다른 연산자(op)와 결합할 수 있다.
#### 그 종류는 다음과 같다.
|      op=      |=|
|:-------------:|:-----:|
|   i += 3;	    |i = i + 3;|
|   i -= 3;	    |i = i - 3;|
|   i *= 3;	    |i = i * 3;|
|   i /= 3;	    |i = i / 3;|
|   i %= 3;	    |i = i % 3;|
|   i <<= 3;	   |i = i << 3;|
|   i >>= 3;	   |i = i >> 3;|
|   i &= 3;	    |i = i & 3;|
|   i ^= 3;	    |i = i ^ 3;|
|    i ｜= 3;    |i = i|
| i *= 10 + j;	 |i = i * (10 + j);|

---
> [출처] : https://velog.io/@appti/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D-Chapter-3.-%EC%97%B0%EC%82%B0%EC%9E%90